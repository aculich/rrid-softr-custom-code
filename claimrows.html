<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/tabulator-tables@6.2.1/dist/css/tabulator.min.css">
    <script type="text/javascript" src="https://unpkg.com/tabulator-tables@6.2.1/dist/js/tabulator.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@2.0.2/build/global/luxon.min.js"></script>
    <style>
        body {
      font-family: Arial, sans-serif;
      background-color: #f4f4f4;
      margin: 0;
      padding: 20px;
    }
    
    .tabulator {
      height: 500px; /* Fixed height */
      width: 100%;   /* Set width to 100% of container */
      max-width: 100%;
      margin: 0 auto; /* Center the table */
      border: 1px solid #ddd; /* Less prominent border */
      border-radius: 4px;
      background: #fff;
      overflow-x: auto; /* Enable horizontal scrolling */
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); /* Add shadow */
      transition: all 0.3s ease; /* Smooth transitions */
    }
    
    .tabulator .tabulator-header {
      background-color: #191d4bff; /* Dark blue header background */
      color: white; /* Header text color */
      font-weight: bold;
    }
    
    .tabulator .tabulator-header .tabulator-col {
      background-color: #191d4bff; /* Dark blue column header background */
      color: white; /* Column header text color */
    }
    
    .tabulator .tabulator-cell {
      white-space: pre-wrap; /* Allow text to wrap */
      border: 1px solid #ddd;
      padding: 10px;
      transition: background-color 0.3s ease; /* Smooth transitions */
    }
    
    .tabulator .tabulator-row {
      border-bottom: 1px solid #ddd;
    }
    
    .tabulator .tabulator-row:nth-child(even) {
      background-color: rgba(78, 189, 210, 0.2); /* Less opaque color */
    }
    
    .tabulator .tabulator-row:nth-child(odd) {
      background-color: #ffffff; /* Alternate row color */
    }
    
    .tabulator .tabulator-row:hover {
      background-color: #e9ecef; /* Hover effect */
    }

    .tabulator .tabulator-row .tabulator-cell input {
      border: none;
      padding: 5px;
      width: 100%;
      box-sizing: border-box;
      font-size: 14px;
      background-color: #ffffff; /* white input background */
      color: #191d4bff; /* dark blue text color */
    }

    .tabulator .tabulator-row .tabulator-cell select {
      border: none;
      padding: 5px;
      width: 100%;
      box-sizing: border-box;
      font-size: 14px;
      background-color: #ffffff; /* white select background */
      color: #191d4bff; /* dark blue text color */
    }

    .tabulator .tabulator-row .tabulator-cell textarea {
      border: none;
      padding: 5px;
      width: 100%;
      box-sizing: border-box;
      font-size: 14px;
      background-color: #ffffff; /* white textarea background */
      color: #191d4bff; /* dark blue text color */
    }
    .tabulator .tabulator-header .tabulator-col.urgent-header {
        background-color: orange;
    }
    

    .tabulator-group.tabulator-group-active {
        display: block; /* Only show active group header */
    }

    

    </style>
</head>
<body>
    <div style="text-align: center; margin-bottom: 10px;">
        <small>Domain</small>
    </div>
    <div id="filter-buttons-domain" style="text-align: center; margin-bottom: 5px;">
        <button class="filter-button-domain" data-domain="PH" style="background-color: white; color: #4ebdd2; border: 2px solid #4ebdd2; border-radius: 4px; padding: 10px; margin-right: 5px; cursor: pointer;">Public Health</button>
        <button class="filter-button-domain" data-domain="MedSci" style="background-color: white; color: #4ebdd2; border: 2px solid #4ebdd2; border-radius: 4px; padding: 10px; margin-right: 5px; cursor: pointer;">Medical Sciences</button>
        <button class="filter-button-domain" data-domain="BCS" style="background-color: white; color: #4ebdd2; border: 2px solid #4ebdd2; border-radius: 4px; padding: 10px; margin-right: 5px; cursor: pointer;">Biological and Chemical Sciences</button>
        <button class="filter-button-domain" data-domain="PSE" style="background-color: white; color: #4ebdd2; border: 2px solid #4ebdd2; border-radius: 4px; padding: 10px; margin-right: 5px; cursor: pointer;">Physical Sciences and Engineering</button>
        <button class="filter-button-domain" data-domain="SSH" style="background-color: white; color: #4ebdd2; border: 2px solid #4ebdd2; border-radius: 4px; padding: 10px; margin-right: 5px; cursor: pointer;">Social Sciences and Humanities</button>
    </div>
    <div style="text-align: center; margin-bottom: 10px;">
        <small>Preprint Status</small>
    </div>
    <div id="filter-buttons-preprint-status" style="text-align: center; margin-bottom: 5px;">
        <button class="filter-button-preprint-status" data-status="ON HOLD" style="background-color: white; color: #050808; border: 2px solid #4ebdd2; border-radius: 4px; padding: 10px; margin-right: 5px; cursor: pointer;">ON HOLD</button>
        <button class="filter-button-preprint-status" data-status="ACTIVE" style="background-color: white; color: #4ebdd2; border: 2px solid #4ebdd2; border-radius: 4px; padding: 10px; margin-right: 5px; cursor: pointer;">ACTIVE</button>
        <button class="filter-button-preprint-status" data-status="COMPLETE" style="background-color: white; color: #4ebdd2; border: 2px solid #4ebdd2; border-radius: 4px; padding: 10px; margin-right: 5px; cursor: pointer;">COMPLETE</button>
    </div>
    
    
    <div id="example-table"></div>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.7.2/dist/axios.min.js"></script>
    <script>
        const airtableToken = 'patxvMWE66lCprz7O.5ff60f4f628a145176a5c5badf898a8d495ae2f704b0895b2cf2d50fffca5c27';
        const baseId = 'appAYosfmfSuHWiBT';
        const tableId = 'tblHRiK0758oaO4jI';
        let table; // Define table variable here


        // Use the logged-in user's email from the window object
        //const userEmail = window['logged_in_user']['softr_user_email'];

        async function fetchData() {
            const url = `https://api.airtable.com/v0/${baseId}/${tableId}`;
            const headers = { Authorization: `Bearer ${airtableToken}` };
            const response = await axios.get(url, { headers });

            return response.data.records
                .map(record => {
                    const fields = record.fields;

                    // Set default values if they are undefined or missing
                    fields.preprintId = fields["Preprint ID (pulled)"];
                    fields.Taken = fields.Taken !== undefined ? fields.Taken : false;
                    fields["Taken Email"] = fields["Taken Email"] !== undefined ? fields["Taken Email"] : null;

                    delete fields["Preprint ID (pulled)"];
                    return { id: record.id, ...fields };
                })
                .filter(record => record["Incomplete?"] !== "Yes"); // Filter out records with "Incomplete?" set to "Yes"
        }


        async function fetchRowData(recordId) {
            const url = `https://api.airtable.com/v0/${baseId}/${tableId}/${recordId}`;
            const headers = { Authorization: `Bearer ${airtableToken}` };
            const response = await axios.get(url, { headers });
            const fields = response.data.fields;

            // Set default values if they are undefined or missing
            fields.preprintId = fields["Preprint ID (pulled)"];
            fields.Taken = fields.Taken !== undefined ? fields.Taken : false;
            fields["Taken Email"] = fields["Taken Email"] !== undefined ? fields["Taken Email"] : null;

            delete fields["Preprint ID (pulled)"];
            return { id: response.data.id, ...fields };
        }


        async function updateAirtable(recordId, fieldName, currentValue) {
            const url = `https://api.airtable.com/v0/${baseId}/${tableId}/${recordId}`;
            const headers = { Authorization: `Bearer ${airtableToken}`, 'Content-Type': 'application/json' };
            const currentDate = new Date().toISOString().split('T')[0]; // Get current date in YYYY-MM-DD format

            const data = {
                fields: {
                    [fieldName]: currentValue,
                  //  'Email of Quality Checker': userEmail, 
                    'Date of Quality Check': currentDate
                }
            };

            try {
                await axios.patch(url, data, { headers });
                console.log(`Updated record ${recordId}: ${fieldName} = ${currentValue}`);
            } catch (error) {
                console.error(`Error updating record ${recordId}:`, error);
            }
        }

        function customMultiSelectFilter(headerValue, rowValue) {
            if (!headerValue || headerValue.length === 0) {
                return true;
            }
            if (Array.isArray(rowValue)) {
                return rowValue.some(val => headerValue.includes(val));
            }
            return headerValue.includes(rowValue);
        }
        // Preload the Status filter
        function preloadStatusFilter() {
            table.setHeaderFilterValue("Status", ["Unchecked", "Fixed", "Double Check"]);
        }

        function customFilter(data) {
            const status = data["Status"];
            const preprintStatus = data["Preprint Status (from Preprint Info ONLY)"];
            console.log('Filtering - Status:', status, 'Preprint Status:', preprintStatus);
            
            // Check if preprintStatus is an array and get the first element if it is
            const preprintStatusValue = Array.isArray(preprintStatus) ? preprintStatus[0] : preprintStatus;
            
            const result = (status === "Unchecked" || status === "Fixed" || status === "Double Check") &&
                        (preprintStatusValue === "ON HOLD" || preprintStatusValue === "ACTIVE");
            console.log('Filter result:', result);
            return result;
        }


        function rowPopupFormatter(row) {
        const existingPopup = document.getElementById("row-popup");
        if (existingPopup) {
        existingPopup.remove();
        }

        const data = row.getData();
        const container = document.createElement("div");
        let contents = "<strong style='font-size:1.2em; display: block; margin-bottom: 10px;'>Row Details</strong><div style='display: flex; flex-direction: column; gap: 10px;'>";

        const columnDefs = [
        { title: "Preprint Title", field: "Preprint Title" },
        { title: "Domain", field: "Domain" },
        { title: "Status", field: "Status", editor: "list", editorParams: { values: ["Invite", "Invite Backup", "Double Check", "Reject", "Fixable", "Unchecked", "Fixed"] }},
        { title: "Quality Check Reviewer Comments", field: "Quality Check Reviewer Comments" },
        { title: "Student Reply Comments", field: "Student Reply Comments" },
        { title: "Reviewer Name", field: "First + Last Name" },
        { title: "Reviewer Email", field: "Reviewer Email" },
        { title: "Backup Reviewer?", field: "Backup Reviewer?" },
        { title: "Invite Backup For...", field: "Invite Backup For..." },
        { title: "Affiliation", field: "Affiliation" },
        { title: "Secondary Affiliation", field: "Secondary Affiliation" },
        { title: "Highest Degree", field: "Highest Degree" },
        { title: "Other Degree", field: "Other Degree" },
        { title: "Title", field: "Title" },
        { title: "Link to Profile", field: "Link to Profile" },
        { title: "Justification for Non-Institutional Profile", field: "Justification for Non-Institutional Profile" },
        { title: "Subdiscipline", field: "Subdiscipline" },
        { title: "Link to Publications", field: "Link to Publications" },
        { title: "Justification if Link to Publications Not Pubmed", field: "Justification if Publications not Pubmed" },
        { title: "Link to Best Match Paper", field: "DOI of Best Match Paper" },
        { title: "Justification for Invite", field: "Justification for Invite" },
        { title: "Student", field: "Student" },
        { title: "Student Email", field: "Student Email" },
        { title: "Date of Proposal", field: "Date of Proposal" },
        { title: "Preprint Status (from Preprint Info ONLY)", field: "Preprint Status (from Preprint Info ONLY)" },
        { title: "Email of Quality Checker", field: "Email of Quality Checker" },
        ];

        const nonEditableFields = [
        "Student",
        "Student Email",
        "Date of Proposal",
        "Preprint Status (from Preprint Info ONLY)",
        "Preprint Title",
        "Domain",
        "Email of Quality Checker"
        ];

        columnDefs.forEach(column => {
        const key = column.field;
        if (key && data[key] !== undefined) {
            let value = data[key];
            if (key === "Backup Reviewer?") {
                value = value ? "Yes" : "No";
            }

            if (nonEditableFields.includes(key)) {
                contents += `<div><strong>${column.title}:</strong> ${value}</div>`;
            } else if (key === "Link to Profile" || key === "Link to Publications" || key === "DOI of Best Match Paper") {
                const displayText = value.startsWith("https") ? value.replace(/^https?:\/\//, '') : value;
                contents += `<div><strong>${column.title}:</strong>
                            <span class="editable-link" data-field="${key}" data-value="${value}">
                                <a href="${value}" target="_blank">${displayText}</a>
                                <input type="text" class="popup-input" style="display:none;" value="${displayText}">
                            </span>
                            </div>`;
            } else if (key === "Status") {
                contents += `<div><strong>${column.title}:</strong> 
                            <select class="popup-input" data-field="${key}">
                                <option value="Invite"${value === "Invite" ? " selected" : ""}>Invite</option>
                                <option value="Invite Backup"${value === "Invite Backup" ? " selected" : ""}>Invite Backup</option>
                                <option value="Double Check"${value === "Double Check" ? " selected" : ""}>Double Check</option>
                                <option value="Reject"${value === "Reject" ? " selected" : ""}>Reject</option>
                                <option value="Fixable"${value === "Fixable" ? " selected" : ""}>Fixable</option>
                                <option value="Unchecked"${value === "Unchecked" ? " selected" : ""}>Unchecked</option>
                                <option value="Fixed"${value === "Fixed" ? " selected" : ""}>Fixed</option>
                            </select>
                            </div>`;
            } else if (key === "Justification for Invite") {
                contents += `<div><strong>${column.title}:</strong> 
                            <textarea class="popup-input" data-field="${key}" rows="4" style="width: 100%;">${value}</textarea>
                            </div>`;
            } else {
                contents += `<div><strong>${column.title}:</strong> 
                            <input type="text" class="popup-input" data-field="${key}" value="${value}" />
                            </div>`;
            }
        }
        });

        contents += "</div>";

        const exitButton = document.createElement("button");
        exitButton.innerHTML = "X";
        exitButton.style.position = "absolute";
        exitButton.style.top = "10px";
        exitButton.style.right = "10px";
        exitButton.style.backgroundColor = "blue";
        exitButton.style.color = "white";
        exitButton.style.border = "none";
        exitButton.style.borderRadius = "50%";
        exitButton.style.cursor = "pointer";
        exitButton.id = "exit-button";

        container.appendChild(exitButton);
        container.innerHTML += contents;
        container.style.position = "fixed";
        container.style.top = "50%";
        container.style.left = "50%";
        container.style.transform = "translate(-50%, -50%)";
        container.style.padding = "20px";
        container.style.border = "1px solid #ddd";
        container.style.backgroundColor = "#fff";
        container.style.boxShadow = "0 2px 10px rgba(0, 0, 0, 0.1)";
        container.style.borderRadius = "4px";
        container.style.maxWidth = "600px";
        container.style.maxHeight = "80%";
        container.style.overflowY = "auto";
        container.style.zIndex = "1000";
        container.id = "row-popup";

        document.body.appendChild(container);

        document.getElementById("exit-button").onclick = function() {
        container.remove();
        var previousHighlightedRow = document.querySelector(".tabulator-row[style*='rgba(78, 189, 210, 0.5)']");
        if (previousHighlightedRow) {
            previousHighlightedRow.style.backgroundColor = "";
        }
        };

        // Attach event listeners to input elements for inline editing
        const inputs = container.querySelectorAll('.popup-input');
        inputs.forEach(input => {
        input.addEventListener('change', function() {
            const field = this.getAttribute('data-field');
            let newValue = this.value;
            console.log(`Updating field ${field} to ${newValue}`);

            if (field === "Link to Publications" || field === "DOI of Best Match Paper") {
                newValue = `https://${newValue.replace(/^https?:\/\//, '')}`;
            }

            row.update({ [field]: newValue });

            // Optionally, update Airtable directly from here
            const recordId = row.getData().id;
            updateAirtable(recordId, field, newValue);
        });
        });

        // Toggle between displaying the link and input field on double-click or right-click
        const editableLinks = container.querySelectorAll('.editable-link');
        editableLinks.forEach(linkContainer => {
        const link = linkContainer.querySelector('a');
        const input = linkContainer.querySelector('input');

        link.addEventListener('click', function(event) {
            // Open link in new tab
            window.open(link.href, '_blank');
        });

        link.addEventListener('contextmenu', function(event) {
            event.preventDefault();
            link.style.display = 'none';
            input.style.display = 'inline-block';
            input.focus();
        });

        input.addEventListener('blur', function() {
            const newValue = input.value;
            const url = newValue.startsWith("https") ? newValue : `https://${newValue}`;
            link.href = url;
            link.textContent = newValue.length > 30 ? newValue.substring(0, 30) + "..." : newValue;
            input.style.display = 'none';
            link.style.display = 'inline';
        });

        input.addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                input.blur();
            }
        });
        });
        }


                







        function expandViewButtonFormatter(cell, formatterParams, onRendered) {
            var button = document.createElement("button");
            button.innerHTML = "Expand View";
            button.style.backgroundColor = "#4ebdd2";
            button.style.color = "white";
            button.style.border = "none";
            button.style.borderRadius = "4px";
            button.style.cursor = "pointer";
            button.onclick = function() {
                var previousHighlightedRow = document.querySelector(".tabulator-row[style*='rgba(78, 189, 210, 0.5)']");
                if (previousHighlightedRow) {
                    previousHighlightedRow.style.backgroundColor = "";
                }
                var currentRowElement = cell.getRow().getElement();
                currentRowElement.style.backgroundColor = "rgba(78, 189, 210, 0.5)";
                rowPopupFormatter(cell.getRow());
            };
            return button;
        }

        // Custom group header formatter to color based on "Urgent" status
        function customGroupHeader(value, count, data, group) {
        const isUrgent = data.some(row => {
        const urgent = row["Urgent"];
        return Array.isArray(urgent) ? urgent.includes("Yes") || urgent.includes(true) : urgent === "Yes" || urgent === true;
        });

        const preprintTitle = data[0]["Preprint Title"];
        const domain = data[0]["Domain"];

        // Return the formatted group header
        return `<span style="display: inline-block; padding: 5px; ${isUrgent ? 'background-color: rgba(255, 0, 0, 0.3); color: black;' : 'color: black;'}">
                ${domain}, ${count} items - ${preprintTitle}
            </span>`;
        }
        // Function to highlight rows with "Duplicate Domain" checked
        function highlightDuplicateDomains() {
        const rows = table.getRows();

        // Highlight rows with "Duplicate Domain" checked
        rows.forEach(row => {
        const duplicateDomain = row.getData()["Duplicate Domain"];
        const rowElement = row.getElement();
        if (duplicateDomain) {
            rowElement.style.backgroundColor = "rgba(255, 165, 0, 0.3)"; // Light orange color
        } else {
            rowElement.style.backgroundColor = ""; // Reset to default
        }
        });
        }


        fetchData().then(data => {
            console.log('Fetched data:', data);
            //const columns = Object.keys(data[0]).map(key => ({ title: key, field: key }));
            /*
            const columns = Object.keys(data[0])
                .filter(key => key !== 'id' && key !== 'Preprint Title' && key !== 'Domain' && key !== 'recordid' && key !== 'preprintId')
                .map(key => ({ title: key, field: key }));
                */

            const columns = [
                { title: "Expand View", field: "expandView", formatter: expandViewButtonFormatter, width: 100, headerSort: false, width: "fitData" },
                
               {
    title: "Taken",
    field: "Taken",
    formatter: "tickCross", // Display checkbox
    editor: true, // Display as a checkbox
    width: "fitData",
    headerSort: false,
    cellClick: async function (e, cell) {
        const row = cell.getRow();
        const recordId = row.getData().id;
        const latestData = await fetchRowData(recordId);
        //row.update(latestData);
        // Check if the row is already claimed by someone else
        console.log("taken: " + latestData["Taken"]);
        console.log("email: " + latestData["Taken Email"]);
        if (latestData["Taken"] && latestData["Taken Email"] !== window['logged_in_user']['softr_user_email']) {
            alert("This record is already taken by another user.");
            row.update(latestData); // Refresh the row to show the latest data
            return;
        }
        else if(latestData["Taken"] && latestData["Taken Email"] == window['logged_in_user']['softr_user_email']) {
            latestData["Taken"] = false;
            latestData["Taken Email"] = null;
            row.update(latestData); // Refresh the row to show the latest data
            return;
        }

        // If not claimed by someone else, toggle the "Taken" status
        const newTakenStatus = !latestData["Taken"];
        const userEmail = window['logged_in_user']['softr_user_email'];

        const updatedData = {
            "Taken": newTakenStatus,
            "Taken Email": newTakenStatus ? userEmail : null
        };

        try {
            // Update Airtable with the new "Taken" status and email
            console.log(`Updating Airtable with the following data for Record ID: ${recordId}`);
            console.log(`New Taken Status: ${newTakenStatus}, Taken Email: ${newTakenStatus ? userEmail : null}`);
            await updateAirtable(recordId, "Taken", newTakenStatus);
            await updateAirtable(recordId, "Taken Email", newTakenStatus ? userEmail : null);
            row.update(updatedData); // Immediately reflect changes in the UI
        } catch (error) {
            console.error(`Error updating record for Record ID: ${recordId}`);
            console.error('Current row data:', row.getData());
            console.error('Error details:', error);
            alert("Failed to update the record. Please try again.");
        }
    }
},


{
    title: "Taken Email",
    field: "Taken Email",
    width: "fitData",
    headerSort: false
},
                {
                    title: "Status",
                    field: "Status",
                    editor: "list",
                    editorParams: { values: ["Invite", "Invite Backup", "Double Check", "Reject", "Fixable", "Unchecked", "Fixed"] },
                    headerFilter: "list",
                    headerFilterParams: {
                        values: ["Invite", "Invite Backup", "Double Check", "Reject", "Fixable", "Unchecked", "Fixed"],
                        multiselect: true,
                        multiselectFilter: true,
                    },
                    headerFilterFunc: customMultiSelectFilter,
                    width: "fitData",
                    headerSort: false
                },
                { title: "Quality Check Reviewer Comments", field: "Quality Check Reviewer Comments" },
                { title: "Student Reply Comments", field: "Student Reply Comments", headerSort: false, width: "fitData"  },
                { title: "Reviewer Name", field: "First + Last Name" },
                { title: "Reviewer Email", field: "Reviewer Email" },
                { title: "Backup Reviewer?", field: "Backup Reviewer?" },
                { title: "Invite Backup For...", field: "Invite Backup For..." },
                { title: "Affiliation", field: "Affiliation" },
                { title: "Secondary Affiliation", field: "Secondary Affiliation" },
                { title: "Highest Degree", field: "Highest Degree", editor: "list",
                    editorParams: { values: ["PhD", "DrPH", "MD", "MBBS", "JD", "EdD", "DO"] },
                },
                { title: "Other Degree", field: "Other Degree" },
                { title: "Title", field: "Title", editor: "list",
                    editorParams: { values: ["Professor", "Associate Professor", "Assistant Professor", "Research Associate Professor", "Director", "Department Head", "Researcher", "Research Officer"] },
                },
                { 
                    title: "Link to Profile", 
                    field: "Link to Profile",
                    width: 200,
                    formatter: function(cell, formatterParams, onRendered) {
                        var value = cell.getValue();
                        if (value && typeof value === 'string' && value.startsWith("https")) {
                            var url = value.startsWith("https") ? value : `https://${value}`;
                            var displayText = value.length > 30 ? value.substring(0, 30) + "..." : value;
                            return `<a href="${url}" target="_blank">${displayText}</a>`;
                        } else {
                            return value || "";
                        }
                    } 
                },
                { title: "Justification for Non-Institutional Profile", field: "Justification for Non-Institutional Profile" },
                { title: "Subdiscipline", field: "Subdiscipline" },
                { 
                    title: "Link to Publications", 
                    field: "Link to Publications",
                    width: 200,
                    formatter: function(cell, formatterParams, onRendered) {
                        var value = cell.getValue();
                        if (value && typeof value === 'string' && value.startsWith("https")) {
                            var url = value.startsWith("https") ? value : `https://${value}`;
                            var displayText = value.length > 30 ? value.substring(0, 30) + "..." : value;
                            return `<a href="${url}" target="_blank">${displayText}</a>`;
                        } else {
                            return value || "";
                        }
                    } 
                },
                { title: "Justification if Link to Publications Not Pubmed", field: "Justification if Publications not Pubmed" },
                { 
                    title: "Link to Best Match Paper", 
                    field: "DOI of Best Match Paper", 
                    width: 200,
                    formatter: function(cell, formatterParams, onRendered) {
                        var value = cell.getValue();
                        if (value && typeof value === 'string' && value.startsWith("https")) {
                            var url = value.startsWith("https") ? value : `https://${value}`;
                            var displayText = value.length > 30 ? value.substring(0, 30) + "..." : value;
                            return `<a href="${url}" target="_blank">${displayText}</a>`;
                        } else {
                            return value || "";
                        }
                    } 
                },
                { title: "Justification for Invite", field: "Justification for Invite" },
                { title: "Student", field: "Student" },
                { title: "Student Email", field: "Student Email" },
                { title: "Email of Quality Checker", field: "Email of Quality Checker" },
                { title: "Date of Proposal", field: "Date of Proposal" },
                { title: "Date of Quality Check", field: "Date of Quality Check" },
                { title: "Preprint Status", field: "Preprint Status (from Preprint Info ONLY)" },
                { title: "Urgent", field: "Urgent" },
                { title: "Duplicate Domain", field: "Duplicate Domain"},
            ];
            console.log('Column Definitions:', columns);

        // Calculate total width of all columns
        const totalWidth = columns.reduce((sum, column) => {
            const columnWidth = column.width === "fitData" ? 150 : (parseInt(column.width) || 150);
            console.log(`Column: ${column.title}, Width: ${columnWidth}`);
            return sum + columnWidth;
        }, 0);

        //console.log("Calculated total width: " + totalWidth);

        // Set the width of the table container
        const tableElement = document.getElementById('example-table');
        tableElement.style.width = `${totalWidth}px`;
        //console.log("Set width of table container: " + tableElement.style.width);


            // Make all fields editable except the "Status" column which has specific settings
            const editableColumns = columns.map(col => {
                if (col.field !== "Status" && col.field !== "expandView" && col.field !== "Student Reply Comments") {
                    return { ...col, editor: "input", headerSort: false, width: "fitData" };
                }
                return col;
            });

            table = new Tabulator("#example-table", {
                data: data, // Load row data into Tabulator
                columns: editableColumns, // Define table columns
                height: "100%",
                layout: "fitDataTable",
                groupBy: "preprintId", // Group rows by Preprint ID
                groupStartOpen: false, // Start with groups collapsed
                
                initialSort: [
                    { column: "Date of Proposal", dir: "asc" }
                ],
                groupHeader: customGroupHeader, 
                /*
                groupHeader: function(value, count, data) {
                    const inviteCount = data[0]["Invite Count"];
                    const preprintTitle = data[0]["Preprint Title"];
                    const domain = data[0]["Domain"];

                    return `${domain}, ${inviteCount} Invites,<span style='color:#d00;'>${count} items</span> - ${preprintTitle}`;
                },*/
                groupToggleElement: "header", // Allow toggling by clicking the group header
            });
        // Color the group headers based on "Urgent"
        function colorUrgentGroupHeaders() {
        console.log("Running colorUrgentGroupHeaders function");

        // First, reset all group headers to the default background color
        table.getGroups().forEach(group => {
        const groupElement = group.getElement();
        groupElement.style.backgroundColor = ""; // Reset to default
        });

        // Then, apply the color to the "Urgent" groups
        table.getGroups().forEach(group => {
        const rows = group.getRows();
        const urgent = rows.some(row => {
            const data = row.getData()["Urgent"];
            const name = row.getData()["Preprint Title"];
            
            return Array.isArray(data) ? data.includes("Yes") || data.includes(true) : data === "Yes" || data === true;
        });

        const groupElement = group.getElement();
        if (urgent) {
            console.log(`Coloring group header for group ${group.getKey()}`);
            console.log("Group element before coloring:", groupElement);
            groupElement.style.backgroundColor = "rgba(255, 0, 0, 0.3)"; // Translucent red color
            console.log("Group element after coloring:", groupElement);
        }
        });
        }

        // Function to handle group header click events with basic logging
        function addGroupHeaderClickListener() {
        const groupHeaders = document.querySelectorAll('.tabulator-group-header');
        groupHeaders.forEach(header => {
        header.addEventListener('click', function() {
            console.log("Group header clicked:", header);
        });
        });
        }

        table.on("tableBuilt", function() {
        console.log("Table built");
        updateTableFilter(); // Call updateTableFilter after table is built
        preloadStatusFilter();
        colorUrgentGroupHeaders();
        highlightDuplicateDomains();
        addGroupHeaderClickListener(); // Add click listeners to group headers
        });

        table.on("dataFiltered", function() {
        console.log("Data filtered");
        colorUrgentGroupHeaders();
        highlightDuplicateDomains();
        });

        table.on("dataLoaded", function() {
        console.log("Data loaded");
        colorUrgentGroupHeaders();
        highlightDuplicateDomains();
        });

        table.on("dataChanged", function() {
        console.log("Data changed");
        colorUrgentGroupHeaders();
        highlightDuplicateDomains();
        });

        table.on("cellEditing", async function(cell) {
    const row = cell.getRow();
    const recordId = row.getData().id;
    const currentData = row.getData();
    const userEmail = window['logged_in_user']['softr_user_email'];

    // Check if the current user is allowed to edit this row
    if (!currentData["Taken"] || currentData["Taken Email"] !== userEmail) {
        // Allow the user to claim the row if "Taken" is unchecked
        if (cell.getColumn().getField() === "Taken" && !currentData["Taken"]) {
            // Update the row to reflect that it is now taken
            row.update({ "Taken": true, "Taken Email": userEmail });
            // Update Airtable
            await updateAirtable(recordId, "Taken", true);
            await updateAirtable(recordId, "Taken Email", userEmail);
        } else if (cell.getColumn().getField() === "Taken" && currentData["Taken"] && currentData["Taken Email"] === userEmail){
            // Update the row to reflect that it is now taken
            row.update({ "Taken": false, "Taken Email": null });
            // Update Airtable
            await updateAirtable(recordId, "Taken", false);
            await updateAirtable(recordId, "Taken Email", null);
        }else{
            alert("You cannot edit this record because it is either not taken or taken by another user.");
            cell.cancelEdit(); // Prevent editing
            return false;
        }
    }

    // Fetch the latest data for the record
    const latestData = await fetchRowData(recordId);
    let dataChanged = false;
    const columns = table.getColumnDefinitions();

    for (const column of columns) {
        const field = column.field;
        const editor = column.editor;
        if (editor && currentData[field] !== undefined) {
            const currentValue = currentData[field];
            const latestValue = latestData[field];
            if (typeof currentValue === 'object' || typeof latestValue === 'object') {
                if (JSON.stringify(currentValue) !== JSON.stringify(latestValue)) {
                    dataChanged = true;
                }
            } else if (currentValue !== latestValue) {
                dataChanged = true;
            }
        }
    }

    if (dataChanged) {
        row.update(latestData); // Refresh the row with the latest data
    }
});



            table.on("cellEdited", function(cell) {
                const row = cell.getRow();
                const rowIndex = row.getPosition();
                const fieldName = cell.getColumn().getField();
                const recordId = row.getData().id;
                const preprintId = row.getData().preprintId;
                const previousValue = cell.getOldValue();
                const currentValue = cell.getValue();

                // Log the changes
                const logMessage = `
                    Cell edited at row ${rowIndex}
                    Field Name: ${fieldName}
                    Record Id: ${recordId}
                    Preprint Id: ${preprintId}
                    Previous value: ${previousValue}
                    Current value: ${currentValue}
                `;
                console.log(logMessage);

                // Update Airtable with the new value
                updateAirtable(recordId, fieldName, currentValue);

                // If the "Taken" checkbox was edited and checked, update the "Taken Email"
                if (fieldName === "Taken" && currentValue === true) {
                    const userEmail = window['logged_in_user']['softr_user_email'];
                    row.update({ "Taken Email": userEmail });

                    // Update Airtable with the new "Taken Email"
                    updateAirtable(recordId, "Taken Email", userEmail);
                   
                }// Ensure that the "Taken" checkbox is immediately updated in the table
                else if (fieldName === "Taken" && !currentValue) {
                    row.update({ "Taken Email": null }); // Clear the "Taken Email" if unchecked

                    // Update Airtable with the cleared "Taken Email"
                    updateAirtable(recordId, "Taken Email", null);
                }
            });
        }).catch(error => {
            console.error('Error fetching data from Airtable:', error);
        });

                
        // Add event listeners to filter buttons
        document.querySelectorAll('.filter-button-domain').forEach(button => {
            button.addEventListener('click', function() {
                if (this.style.backgroundColor === 'rgb(78, 189, 210)') { // if already selected
                    this.style.backgroundColor = 'white'; // deselect
                    this.style.color = '#4ebdd2';
                    this.style.border = '2px solid #4ebdd2';
                } else {
                    this.style.backgroundColor = '#4ebdd2'; // select
                    this.style.color = 'white';
                    this.style.border = 'none';
                }
                updateTableFilter();
            });
        });
        // Select "ON HOLD" and "ACTIVE" buttons by default
        document.querySelectorAll('.filter-button-preprint-status[data-status="ON HOLD"], .filter-button-preprint-status[data-status="ACTIVE"]').forEach(button => {
            button.style.backgroundColor = '#4ebdd2';
            button.style.color = 'white';
            button.style.border = 'none';
            updateTableFilter();
        });


        document.querySelectorAll('.filter-button-preprint-status').forEach(button => {
            button.addEventListener('click', function() {
                if (this.style.backgroundColor === 'rgb(78, 189, 210)') { // if already selected
                    this.style.backgroundColor = 'white'; // deselect
                    this.style.color = '#4ebdd2';
                    this.style.border = '2px solid #4ebdd2';
                } else {
                    this.style.backgroundColor = '#4ebdd2'; // select
                    this.style.color = 'white';
                    this.style.border = 'none';
                }
                updateTableFilter();
            });
        });


        // Function to update the table filter based on selected buttons
        function updateTableFilter() {
            const selectedDomains = Array.from(document.querySelectorAll('.filter-button-domain'))
                                        .filter(button => button.style.backgroundColor === 'rgb(78, 189, 210)')
                                        .map(button => button.getAttribute('data-domain'));

            const selectedPreprintStatuses = Array.from(document.querySelectorAll('.filter-button-preprint-status'))
                                        .filter(button => button.style.backgroundColor === 'rgb(78, 189, 210)')
                                        .map(button => button.getAttribute('data-status'));

            if (table) { // Ensure table is defined
                table.clearFilter(true); // clear existing filters but retain header filters

                if (selectedDomains.length > 0) {
                    table.addFilter(function(data) {
                        const domains = data["Domain"];
                        if (Array.isArray(domains)) {
                            return domains.some(domain => selectedDomains.includes(domain));
                        }
                        return selectedDomains.includes(domains);
                    });
                }

                if (selectedPreprintStatuses.length > 0) {
                    table.addFilter(function(data) {
                        const preprintStatus = data["Preprint Status (from Preprint Info ONLY)"];
                        if (Array.isArray(preprintStatus)) {
                            return preprintStatus.some(status => selectedPreprintStatuses.includes(status));
                        }
                        return selectedPreprintStatuses.includes(preprintStatus);
                    });
                }

               
            }
        }



    </script>
</body>
</html>



